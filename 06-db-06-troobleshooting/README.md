# Домашнее задание к занятию "6.6. Troubleshooting"

## Задача 1

Перед выполнением задания ознакомьтесь с документацией по [администрированию MongoDB](https://docs.mongodb.com/manual/administration/).

Пользователь (разработчик) написал в канал поддержки, что у него уже 3 минуты происходит CRUD операция в MongoDB и её 
нужно прервать. 

Вы как инженер поддержки решили произвести данную операцию:
- напишите список операций, которые вы будете производить для остановки запроса пользователя

__ответ:__

Основной метод для прерывания выполняемой операции чтения -  `db.killOp(<opId>)` , может быть использован для операции иницированых клиентом, но не внутренними операциями БД 
	
При использовании кластеров для версий Mongo 4+ операция прерывается автоматически на всех шардах, если версия 3.6 и младше надо вручную на всех шардах

Прерывание операций записи: (1) в случае сессии через mongos - команда `killSessions`, (2) без сессии сборка id через `$currentOp` на всех шардах и использование метода `db.killOp(<opId>)`

В любом случае сначала получаем id операции с помощью `$currentOp` 

Примерная последовательность: 

```mongo
use admin
db.aggregate( [
   { $currentOp : { allUsers: true } },
   { $match : <filter condition> } // Optional.  Specify the condition to find the op.
                                   // e.g. { op: "getmore", "command.collection": "someCollection" }
] )

db.killOp(<opid of the query to kill>)
//или
db.killOp("shardB:79014");
db.killOp("shardA:100813");
```

- предложите вариант решения проблемы с долгими (зависающими) запросами в MongoDB

> основной вариант установка лимита на время операции через метод  `maxTimeMS()`, причем по истечении времени используется механизм `db.killOp()`

## Задача 2

Перед выполнением задания познакомьтесь с документацией по [Redis latency troobleshooting](https://redis.io/topics/latency).

Вы запустили инстанс Redis для использования совместно с сервисом, который использует механизм TTL. 
Причем отношение количества записанных key-value значений к количеству истёкших значений есть величина постоянная и
увеличивается пропорционально количеству реплик сервиса. 

При масштабировании сервиса до N реплик вы увидели, что:
- сначала рост отношения записанных значений к истекшим
- Redis блокирует операции записи

Как вы думаете, в чем может быть проблема?

__ответ:__

с латентностью на удаление истекших ключей при запросах по всей системе. В redis 2 механихма удаления ключей:
- ленивый (lazy) - удаление при запросе просроченного значения
- активный - работает в фоне и тестирует 20 случайных ключей на сервере ккаждые 10 мс (то есть 200 ключей в секунду), когда находим больше 25% просроченных ключей процесс случайного поиска запускается снова. 

Таким образом если находится много истекающих ключей Redis может блокировать запросы пока не опустит число истекающих ниже 25%

Решение корректнее подбирать TTL - очень короткое может быть опасно из-за постоянного удаления, очень большое может привести к большим затратам ОЗУ.
 
## Задача 3

Вы подняли базу данных MySQL для использования в гис-системе. При росте количества записей, в таблицах базы,
пользователи начали жаловаться на ошибки вида:
```python
InterfaceError: (InterfaceError) 2013: Lost connection to MySQL server during query u'SELECT..... '
```

Как вы думаете, почему это начало происходить и как локализовать проблему?
Какие пути решения данной проблемы вы можете предложить?

- возможные причины ошибки - слишком долго выполняется запрос, и происходит обрыв соединения по таймауту, поскольку для поддержания связи используется простой запрос типа SELECT 1, но он не выполняется пока не получен результат предыдущего.  
в таком случае вариант увеличить переменную - `connect_timeout` 

- Также возможно проблема в размере ответа, тогда решение может быть в увеличении параметров:
`max_allowed_packet` (по умолчанию 1 М) до реальных размеров 

## Задача 4

Вы решили перевести гис-систему из задачи 3 на PostgreSQL, так как прочитали в документации, что эта СУБД работает с 
большим объемом данных лучше, чем MySQL.

После запуска пользователи начали жаловаться, что СУБД время от времени становится недоступной. В dmesg вы видите, что:

`postmaster invoked oom-killer`

Как вы думаете, что происходит?
OOM-killer (Out-of-Memory) - механизм принудительного завершения процесса в Linux,  если заканчивается свободная память или место.
Проблема есть документации postgres (`memory overcommit`), т.е. Linux выделяет чрезмерно памяти для сервера postgres

Как бы вы решили данную проблему?
в документации варианты решения - использовать выделенный сервер для postgres, увеличивать физическую или виртуальную память.
Также возможно изменение настроек  `shared_buffers`, `work_mem` и `hash_mem_multiplier`.
+ можно уменьшить число разрешенных соединений 
+ можно изменить настройки механизма в ОС - `sysctl -w vm.overcommit_memory=2`
+ убрать postmaster из отключаемых при исчерпании памяти  

```
echo -1000 > /proc/self/oom_score_adj
export PG_OOM_ADJUST_FILE=/proc/self/oom_score_adj
export PG_OOM_ADJUST_VALUE=0
```

при использовании kubernets  гуглить дальше  - https://www.crunchydata.com/blog/deep-postgresql-thoughts-the-linux-assassin

---
